"--------------------------------------------------------------------
" Vim Einstellungsdatei
"--------------------------------------------------------------------
" Diese Datei sollte alle Einstellungen enthalten, die Vim im
" Allgemeinen und im Speziellen betreffen. Einstellungen, die GVim
" im Speziellen betreffen gehören in $HOME/.gvimrc .
"
" Alle Einstellungen sind grob in vier Bereiche eingeteilt:
" - Generelle Einstellungen
" - Key mappings für eigene Makros
" - Skript-spezifische Einstellungen
" - Spielplatz (Testweise eingebaute Einstellungen, Makros und
"   Snippets. Einstellungen, die wirklich nur kurz ausprobiert
"   werden sollen, sollten zunächst in einer seperaten Datei stehen
"   und per source eingebunden werden.)
"
" Sollten einige dieser Einstellungsbereiche zu groß werden, oder zu
" einem bestimmten Skript zu viele Einstellungen nötig sein, lohnt es
" sich diese in eine eigene Datei zu exportieren und in dieser Datei
" per source einzubinden.
" Alle Einstellungen sollte sorgfältig und am besten mit Zweck,
" Quelle, Autor kommentiert werden!
"
" Diese Tipps stammen aus "Hacking Vim" von Kim Schulz aus dem
" "Appendix B".

" Pathogen
" --------
" These lines have to be called before enabling filetype detection.
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

" Vundle
" ------
set nocompatible
filetype off
set rtp+=$HOME/.vim/vundles/vundle
call vundle#rc($HOME . '/.vim/vundles')
Bundle 'gmarik/vundle'

" -------------------------------------------------------------------
" VUNDLES
" -------------------------------------------------------------------
Bundle 'altercation/vim-colors-solarized.git'
Bundle 'fs111/pydoc.vim.git'
Bundle 'godlygeek/csapprox.git'
Bundle 'godlygeek/tabular.git'
Bundle 'gregsexton/gitv.git'
Bundle 'kevinw/pyflakes-vim.git'
Bundle 'Lokaltog/vim-easymotion.git'
Bundle 'majutsushi/tagbar.git'
Bundle 'mattn/gist-vim.git'
Bundle 'msanders/snipmate.vim.git'
Bundle 'Rip-Rip/clang_complete.git'
Bundle 'scrooloose/nerdcommenter.git'
Bundle 'scrooloose/nerdtree.git'
Bundle 'scrooloose/syntastic.git'
Bundle 'sjl/gundo.vim.git'
Bundle 'sontek/rope-vim.git'
Bundle 'tmallen/proj-vim.git'
Bundle 'tpope/vim-fugitive.git'
Bundle 'tpope/vim-repeat.git'
Bundle 'tpope/vim-speeddating.git'
Bundle 'tpope/vim-surround.git'
Bundle 'tpope/vim-unimpaired.git'
Bundle 'vim-scripts/bufkill.vim.git'
Bundle 'vim-scripts/FuzzyFinder.git'
Bundle 'vim-scripts/info.vim.git'
Bundle 'vim-scripts/Justify.git'
Bundle 'vim-scripts/L9.git'
Bundle 'vim-scripts/pep8.git'
Bundle 'vim-scripts/python_match.vim.git'
Bundle 'vim-scripts/ScrollColors.git'
Bundle 'vim-scripts/shell.vim--Odding.git'
Bundle 'vim-scripts/taglist.vim.git'
Bundle 'vim-scripts/TaskList.vim.git'
Bundle 'vim-scripts/Vimball.git'
Bundle 'xolox/vim-notes.git'
Bundle 'yurifury/hexHighlight.git'
"---------------------------------------------------------------------

"---------------------------------------------------------------------
" Generelle Einstellungen
"---------------------------------------------------------------------

" When started as "evim", evim.vim will already have done these settings.
" Aus vimrc_example von Bram Moolenar
if v:progname =~? "evim"
  finish
endif

" Keine Kompatibilität mit Vi! Viele Scripts setzen das voraus.
set nocompatible

" allow backspacing over everything in insert mode
" Aus vimrc_example von Bram Moolenar
set backspace=indent,eol,start

" Aus vimrc_example von Bram Moolenar
if has("vms")
  set nobackup		" do not keep a backup file, use versions instead
else
  set backup		" keep a backup file
endif
set history=50		" keep 50 lines of command line history
set ruler		" show the cursor position all the time
set showcmd		" display incomplete commands
set incsearch		" do incremental searching

" In many terminal emulators the mouse works just fine, thus enable it.
" Aus vimrc_example von Bram Moolenar
set mouse=a

" Allow moving after the end of line in visual block mode.
" ctrl+v $ still selects to individual line ends.
set virtualedit+=block

" Switch syntax highlighting on, when the terminal has colors
" Also switch on highlighting the last used search pattern.
" Aus vimrc_example von Bram Moolenar
if &t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

" Searching test will find test, Test, tEst, etc.
" while search Test will find Test.
" set ignorecase
set smartcase

" Lilypond config file
set runtimepath+=/usr/share/lilypond/2.10.33/vim/

" Only do this part when compiled with support for autocommands.
" Aus vimrc_example von Bram Moolenar
if has("autocmd")

  " Enable file type detection.
  " Use the default filetype settings, so that mail gets 'tw' set to 72,
  " 'cindent' is on in C files, etc.
  " Also load indent files, to automatically do language-dependent indenting.
  filetype plugin indent on

  " Put these in an autocmd group, so that we can delete them easily.
  augroup vimrcEx
  au!

  " filetype settings
  autocmd FileType text setlocal autoindent
  autocmd FileType gitconfig setlocal sw=8 noexpandtab
  autocmd FileType html,css,scss,ruby,yaml,vim,sh,tex
	\ setlocal sts=2 sw=2
  autocmd FileType c,cpp setlocal sw=4 noexpandtab
  autocmd FileType python setlocal sw=4 sts=4 expandtab
  autocmd FileType javascript setlocal sts=4 sw=4 noexpandtab
  autocmd BufNewFile,BufRead *.rss setfiletype xml
  " list view
  autocmd FileType c,cpp,sh,python,tex,make setlocal list
  " formatoptions
  autocmd FileType c,cpp,sh,python,make setlocal formatoptions=croqn
  autocmd FileType tex setlocal formatoptions=tcroqlwn
  autocmd FileType text setlocal formatoptions=tcroqn
  autocmd FileType text,c,cpp,tex,sh,python setlocal textwidth=78
  " to use an external format program use
  "   :set formatprg=par
  "   :set formatprg=par\ -w78

  " C++ include path
  let s:gpppath='g++ -v 2>&1 ' .
	\ '|sed -r ''/--with-gxx-include-dir=/!d;' .
	\ 's/.*--with-gxx-include-dir=(\S*).*/\1/'''
  autocmd FileType cpp exec 'setlocal path+='.system(s:gpppath)
  autocmd BufNewFile,BufRead /usr/include/c++* setfiletype cpp

  " When editing a file, always jump to the last known cursor position.
  " Don't do it when the position is invalid or when inside an event handler
  " (happens when dropping a file on gvim).
  autocmd BufReadPost *
    \ if line("'\"") > 0 && line("'\"") <= line("$") |
    \   exe "normal! g`\"" |
    \ endif

  " Lädt automatisch abhängig von der Dateiendung ein Template, sofern
  " vorhanden Aus "Hacking Vim" von Kim Schulz
  if has("autocmd")
    autocmd BufNewFile * silent! 0r $HOME/.vim/templates/%:e.tpl
  endif

  augroup END

else

  set autoindent		" always set autoindenting on

endif " has("autocmd")

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Aus vimrc_example von Bram Moolenar
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
	 	\ | wincmd p | diffthis

" Farbschema für Vim auf der Konsole setzen.
colorscheme zenburn

" Informative Statuszeile, die immer sichtbar ist
" Aus "Hacking Vim" von Kim Schulz
" Der komplizierte, lange Befehl erfragt das encoding und Byte Order Mark
" geklaut aus der VIM-Wiki:
" http://vim.wikia.com/wiki/Show_fileencoding_and_bomb_in_the_status_line
set statusline=%<
      \%{(exists('*SyntasticStatuslineFlag')?SyntasticStatuslineFlag():\"\")}
      \%f%h%m%r
      \%{(exists('*fugitive#statusline')?fugitive#statusline():\"\")}
      \\ [%{&ff}]%{\"
      \[\".(&fenc==\"\"?&enc:&fenc).
      \((exists(\"+bomb\")\ &&\ &bomb)?\",B\":\"\").
      \\"]\"}%=\ [\%03b,x\%02B]\ [%v,%l][%p%%][%L]
set laststatus=2

" Sprachen für die Rechtschreibprüfung. Die Rechtschreibprüfung selbst
" sollte in ftplugins gesetzt werden.
set spelllang=de,en

" Eigene allgemeine Abkürzungen einbinden
" Aus "Hacking Vim" von Kim Schulz
source $HOME/.vim/abbreviations.vim

" Ermöglicht es nichtgespeicherte Puffer zu verstecken, wenn ein Kommando wie
" :edit {file} den aktuellen Puffer braucht.
set hidden

" Cooleres Tab-Menü
set wildmenu

" Shiftwidth auf 4 stellen. Tabstop sollte unberührt bleiben!
" Shiftwidth nur für den aktuellen Puffer setzen, in anderen könnte es
" durch ftplugins beeinflusst sein.
setlocal sw=2
" softtabstop bewirkt 4-Zeichen tab im insert-mode ohne tabstop zu ändern.
setlocal softtabstop=4

" Tabulator am Zeilenanfang auf sw setzen.
set smarttab

" cd into the directory the current buffer is in.
com! CD cd %:p:h
com! LCD lcd %:p:h

" Quick editing and automatic sourcing of vimrc file.
if has("autocmd")
  " :autocmd! config to disable automatic sourcing
  augroup config
    au!
    autocmd bufwritepost .vimrc source $MYVIMRC |
	  \if has('gui_running') | source $MYGVIMRC | endif | let &ft=&ft
    autocmd bufwritepost .gvimrc if has('gui_running') | 
	  \source $MYGVIMRC | let &ft=&ft | endif
  augroup END
endif
com! Evimrc tabedit $MYVIMRC
com! Egvimrs tabedit $MYGVIMRC
com! Sorc source $MYVIMRC | 
      \if has('gui_running') | source $MYGVIMRC | endif | let &ft=&ft

" A function, that preserves the cursor position while executing a command.
function! Preserve(command)
  " Preparation: save last search, and cursor position.
  let _s=@/
  let l = line(".")
  let c = col(".")
  " Do the business:
  execute a:command
  " Clean up: restore previous search history, and cursor position
  let @/=_s
  call cursor(l, c)
endfunction

" Underlining tool
function! s:Underline(chars)
  let chars = empty(a:chars) ? '-' : a:chars
  let nb_chars = len(chars)
  let nb_columns = virtcol('$') - 1
  if has('float')
    let nb_insertions = floor(nb_columns / str2float(nb_chars))
    let remainder = nb_columns % nb_chars
  else
    let nb_insertions = nb_columns / nb_chars
  endif
  let saveFormatoptions = &formatoptions
  set formatoptions-=o
  execute "normal! o\<esc>"
  let &formatoptions = saveFormatoptions
  if has('float')
    execute 'normal! ' . float2nr(nb_insertions) . 'i' . chars . "\<esc>"
    if !empty(remainder)
      execute 'normal! A' . strpart(chars, 0, remainder) . "\<esc>"
    endif
  else
    execute 'normal! ' . nb_insertions . 'i' . chars . "\<esc>"
  endif
endfunction
command! -nargs=? Underline call <sid>Underline(<q-args>)

" Strip trailing white spaces
nmap <silent> _$ :call Preserve("%s/\\s\\+$//e")<CR>

" Align whole file
nmap <silent> _= :call Preserve("normal gg=G")<CR>

" Nice characters in listing mode
"   unicode values: ▸ 9656(x25B8), ╴ 9588(x2574), ¬ 172(xAC),
"                   ⍽ 9085(x237D), ␣ 9251(x2423)
if has("multi_byte")
  set listchars=tab:▸\ ,eol:¬,nbsp:⍽,trail:␣
endif

" chmod of current file
command! -nargs=? Chmod :!chmod <q-args> "%"
nnoremap <silent> <leader>X :Chmod +x<CR>

" Soft linewrapping
"   to insert unicode characters use ctrl-vu charcode
if has("multi_byte")
  command! -nargs=* Wrap set wrap linebreak nolist showbreak=…
else
  command! -nargs=* Wrap set wrap linebreak nolist showbreak=~
endif
command! -nargs=* Nowrap set nowrap
map  <A-j> gj
map  <A-k> gk
map  <A-4> g$
map  <A-6> g^
map  <A-^> g^
map  <A-0> g^
imap <A-j> <C-o>gj
imap <A-k> <C-o>gk
imap <A-4> <C-o>g$
imap <A-6> <C-o>g^
imap <A-^> <C-o>g^
imap <A-0> <C-o>g^

" Python virtualenv
"   [http://sontek.net/turning-vim-into-a-modern-python-ide#virtualenv]
if !empty($VIRTUAL_ENV)
python << EOF
import os.path
import sys
import vim
if 'VIRTUAL_ENV' in os.environ:
  project_base_dir = os.environ['VIRTUAL_ENV']
  sys.path.insert(0, project_base_dir)
  activate_this = os.path.join(project_base_dir, 'bin/activate_this.py')
  execfile(activate_this, dict(__file__=activate_this))
EOF
endif

" Use undofile
" [refer to http://amix.dk/blog/post/19548]
set undofile

"---------------------------------------------------------------------
" Key mappings für eigene Makros
"---------------------------------------------------------------------

let mapleader = ','

" Underline mappings
nnoremap <silent> <leader>u :Underline -<CR>
nnoremap <silent> <leader>U :Underline =<CR>
nnoremap <silent> <leader>uu :Underline -<CR>
nnoremap <silent> <leader>UU :Underline =<CR>
nnoremap <silent> <leader>uc :Underline -<CR>
      \Vk:call NERDComment(1, 'alignBoth')<CR>
nnoremap <silent> <leader>Uc :Underline =<CR>
      \Vk:call NERDComment(1, 'alignBoth')<CR>

" Don't use Ex mode, use Q for formatting
" Aus vimrc_example von Bram Moolenar
map Q gq

" Show quickfix window for current search with <leader>q/
nnoremap <silent> <leader>q/ :execute 'vimgrep /'.@/.'/g %'<CR>:copen<CR>
" Further quickfix mappings
nnoremap <leader>qo :copen<CR>
nnoremap <leader>qc :cclose<CR>
nnoremap ]q :cnext<CR>
nnoremap [q :cprevios<CR>
" Some locationlist mappings
nnoremap <leader>lo :lopen<CR>
nnoremap <leader>lc :lclose<CR>
nnoremap ]l :lnext<CR>
nnoremap [l :cprevious<CR>

" Toggle automatic formatting
map <silent> <Leader>f :if &formatoptions =~# 'a' <Bar>
      \ set formatoptions-=a <Bar>
      \ else <Bar>
      \ set formatoptions+=a <Bar>
      \ endif<CR>

" mappings to easily edit files, that are within the same directory as the
" current file.
cnoremap %% <C-R>=expand('%:h').'/'<cr>
map <leader>ew :e %%
map <leader>es :sp %%
map <leader>ev :vsp %%
map <leader>et :tabe %%

" Intuitives Springen durch Zeilen, die umgebrochen wurden.
" Aus "Hacking Vim" von Kim Schulz
map <DOWN> gj
map <UP> gk
imap <DOWN> <C-o>gj
imap <UP> <C-o>gk

" Single line scrolling
nmap <C-PageUP> <C-Y>
nmap <C-PageDown> <C-E>
imap <C-PageUP> <C-o><C-Y>
imap <C-PageDown> <C-o><C-E>

" Text bubbling - http://vimcasts.org/episodes/bubbling-text/
" using the unimpared.vim package
nmap <C-Up> [e
nmap <C-Down> ]e
vmap <C-Up> [egv
vmap <C-Down> ]egv

" Visually select the text that way last edited/pasted
nmap gV `[v`]

" Einige aus den MS Visual Studios gewohnte Tastenkürzel
imap <C-CR> <ESC>O
imap <C-BS> <C-w>

" Schneller Zugang zur Hilfe automatisch zum Wort unter dem Cursor
" Aus "Hacking Vim" von Kim Schulz
map <F1> <ESC>:exec "help ".expand("<cWORD>")<CR>

" Go to next and previous file
nnoremap <C-right> :next<CR>
nnoremap <C-left> :prev<CR>
nnoremap <C-home> :first<CR>
nnoremap <C-end> :last<CR>

"---------------------------------------------------------------------
" Skript-spezifische Einstellungen
"---------------------------------------------------------------------

" snipMate
" --------
let g:snips_author = 'Andreas Herrmann'
" To redifine the trigger key, refer tp :help snipMate-remap
" Indentation is affected by softtabstop or expandtab

" surround
" --------
" Leave visual mode s mapping alone.
xmap <leader>s <Plug>Vsurround

" NERD-Commenter
" --------------
let NERDRemoveExtraSpaces = 1
let NERDSpaceDelims = 1

" NERD-Tree
" ---------
map <F2> :NERDTreeToggle<CR>

" Gundo
" -----
nnoremap <F3> :GundoToggle<CR>

" TagList
" -------
" nnoremap <F4> :TlistToggle<CR>

" TagBar
" ------
"  Show tagbar on the left side. Expand gvim window when doing so.
let g:tagbar_left = 1
let g:tagbar_expand = 1
nnoremap <F4> :TagbarToggle<CR>

" Alternate
" ---------
map <leader>a :A<CR>

" Tabular
" -------
" short-keys [http://vimcasts.org/episodes/aligning-text-with-tabular-vim/]
nmap <Leader>t= :Tabularize /=<CR>
vmap <Leader>t= :Tabularize /=<CR>
" [:help \zs, :help \ze]
nmap <Leader>t: :Tabularize /:\zs<CR>
vmap <Leader>t: :Tabularize /:\zs<CR>

" Automatical alignment
"   [http://vimcasts.org/episodes/aligning-text-with-tabular-vim/]
"   requires that the first line of the table is already aligned.
"   I.e. | 1 | 2 | 3 | rather than |1|2|3|.
inoremap <silent> <Bar>   <Bar><Esc>:call <SID>align()<CR>a
 
function! s:align()
  let p = '^\s*|\s.*\s|\s*$'
  if exists(':Tabularize') && getline('.') =~# '^\s*|' && (getline(line('.')-1) =~# p || getline(line('.')+1) =~# p)
    let column = strlen(substitute(getline('.')[0:col('.')],'[^|]','','g'))
    let position = strlen(matchstr(getline('.')[0:col('.')],'.*|\s*\zs.*'))
    Tabularize/|/l1
    normal! 0
    call search(repeat('[^|]*|',column).'\s\{-\}'.repeat('.',position),'ce',line('.'))
  endif
endfunction

" Latex-Suite
" -----------
let g:Tex_DefaultTargetFormat='pdf'
if executable('evince')
  let g:Tex_ViewRule_pdf='evince'
endif
let g:Tex_UseMakefile=1

set grepprg=grep\ -nH\ $*\ /dev/null

" Gist
" ----
let g:gist_clip_command = 'xclip -selection clipboard'
let g:gist_detect_filetype = 1
let g:gist_open_browser_after_post = 1

" Syntastic
" ---------
let g:syntastic_enable_signs = 1
" let g:syntastic_auto_jump = 1
" Either type :Errors or use <leader>lo to open the location list.
let g:syntastic_auto_loc_list = 2
let g:syntastic_stl_format = '%E{%eE}%W{%wW}!'
let g:syntastic_disabled_filetypes = ['c', 'cpp', 'tex']

" Clang-Complete
" --------------
" unfortunately too slow
let g:clang_complete_auto = 0
if filereadable($HOME.'/usr/lib/libclang.so')
  let g:clang_use_library = 1
  let g:clang_library_path = $HOME.'/usr/lib'
endif

" Task-List
" ---------
map <leader>d <Plug>TaskList

" Fuzzy-Finder
" ------------
let g:fuf_modesDisable = []
let g:fuf_mrufile_maxItem = 400
let g:fuf_mrucmd_maxItem = 400
nnoremap <silent> <leader>sj     :FufBuffer<CR>
nnoremap <silent> <leader>sk     :FufFileWithCurrentBufferDir<CR>
nnoremap <silent> <leader>sK     :FufFileWithFullCwd<CR>
nnoremap <silent> <leader>s<C-k> :FufFile<CR>
nnoremap <silent> <leader>sl     :FufCoverageFileChange<CR>
nnoremap <silent> <leader>sL     :FufCoverageFileChange<CR>
nnoremap <silent> <leader>s<C-l> :FufCoverageFileRegister<CR>
nnoremap <silent> <leader>sd     :FufDirWithCurrentBufferDir<CR>
nnoremap <silent> <leader>sD     :FufDirWithFullCwd<CR>
nnoremap <silent> <leader>s<C-d> :FufDir<CR>
nnoremap <silent> <leader>sn     :FufMruFile<CR>
nnoremap <silent> <leader>sN     :FufMruFileInCwd<CR>
nnoremap <silent> <leader>sm     :FufMruCmd<CR>
nnoremap <silent> <leader>su     :FufBookmarkFile<CR>
nnoremap <silent> <leader>s<C-u> :FufBookmarkFileAdd<CR>
vnoremap <silent> <leader>s<C-u> :FufBookmarkFileAddAsSelectedText<CR>
nnoremap <silent> <leader>si     :FufBookmarkDir<CR>
nnoremap <silent> <leader>s<C-i> :FufBookmarkDirAdd<CR>
nnoremap <silent> <leader>st     :FufTag<CR>
nnoremap <silent> <leader>sT     :FufTag!<CR>
nnoremap <silent> <leader>s<C-]> :FufTagWithCursorWord!<CR>
nnoremap <silent> <leader>s,     :FufBufferTag<CR>
nnoremap <silent> <leader>s<     :FufBufferTag!<CR>
vnoremap <silent> <leader>s,     :FufBufferTagWithSelectedText!<CR>
vnoremap <silent> <leader>s<     :FufBufferTagWithSelectedText<CR>
nnoremap <silent> <leader>s}     :FufBufferTagWithCursorWord!<CR>
nnoremap <silent> <leader>s.     :FufBufferTagAll<CR>
nnoremap <silent> <leader>s>     :FufBufferTagAll!<CR>
vnoremap <silent> <leader>s.     :FufBufferTagAllWithSelectedText!<CR>
vnoremap <silent> <leader>s>     :FufBufferTagAllWithSelectedText<CR>
nnoremap <silent> <leader>s]     :FufBufferTagAllWithCursorWord!<CR>
nnoremap <silent> <leader>sg     :FufTaggedFile<CR>
nnoremap <silent> <leader>sG     :FufTaggedFile!<CR>
nnoremap <silent> <leader>so     :FufJumpList<CR>
nnoremap <silent> <leader>sp     :FufChangeList<CR>
nnoremap <silent> <leader>sq     :FufQuickfix<CR>
nnoremap <silent> <leader>sy     :FufLine<CR>
nnoremap <silent> <leader>sh     :FufHelp<CR>
nnoremap <silent> <leader>se     :FufEditDataFile<CR>
nnoremap <silent> <leader>sr     :FufRenewCache<CR>

" Pep-8
" -----
let g:pep8_map = '<leader>8'

" Fugitive
" --------
if has("autocmd")
  augroup Fugitive
    au!
    autocmd BufEnter fugitive://*
	  \ if fugitive#buffer().type() =~# '^\%(tree\|blob\)' |
	  \   nnoremap <buffer> .. :edit %:h<CR> |
	  \ endif |
	  \ set bufhidden=delete |
  augroup END
endif

" Shell
" -----
let g:shell_mappings_enable = 0
nmap <silent> go :Open<CR>

"---------------------------------------------------------------------
" Spielplatz
"---------------------------------------------------------------------

